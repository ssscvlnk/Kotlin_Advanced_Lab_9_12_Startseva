# Лабораторная работа №9-12: Продвинутое ООП на Kotlin
## Описание
Лабораторная работа посвящена изучению продвинутых концепций объектно-ориентированного программирования в Kotlin. 
## Структура проекта
Проект содержит примеры реализации продвинутых механизмов ООП, а также пояснения к ключевым концепциям. 
## Как запустить проект
1. Клонируйте репозиторий: ```bash
git clone <URL_репозитория>``` 
2. Откройте проект в IntelliJ IDEA. 
3. Запустите любой пример через контекстное меню или напрямую из `main`. 
## Автор
   [Старцева П.С.]
## Лицензия
Проект создан в учебных целях.
## Инкапсуляция
Это принцип ООП, который скрывает внутреннее
состояние объекта и позволяет управлять доступом к нему — чтобы нельзя было
случайно присвоить неправильные данные.

Kotlin реализует инкапсуляцию с помощью:
1. модификаторов доступа (private, protected, internal, public)
2. кастомных геттеров и сеттеров 
3. делегирования свойств (lazy, observable)
## Геттеры-сеттеры
Позволяют защитить объект от некорректного состояния. 

Field - скрытое автоматически созданное хранилище данных. Внутри
геттера/сеттера только оно хранит фактическое значение свойства.

Пример:

Напишем внутри класса свойство health с кастомным сеттером. 
``` 
class Hero(val name: String) {
    var health: Int = 100
        set(value) {
            field = value.coerceIn(0,100)
        } 
```
Напишем внутри класса новое свойство stamina с кастомным геттером
``` 
var stamina: Int = 50
        get() = field + 10
```
Напишем свойство level с приватным сеттером
```
var level: Int = 1
        private set
```
Напишем метод для повышения уровня
```
fun levelUp() {
        level++
        println("$name повысил уровень до $level")
    }
}
```
Краткий вывод по нашему классу:
* health защищён от некорректных значений 
* stamina рассчитывается динамически 
* level закрыт от внешнего изменения

## Data-классы
Это специальный тип класса в Kotlin,
предназначенный в первую очередь для хранения данных. Основное преимущество
data-классов — автоматическая генерация стандартных методов, которые обычно
приходится писать вручную.

Автоматически генерируемые методы:
* toString() — возвращает строковое представление объекта; 
* equals() — сравнивает два объекта на равенство; 
* hashCode() — возвращает хеш-код объекта; 
* copy() — копирует данные объекта в другой объект; 
* componentN() — функции для декомпозиции.

Пример:

Data-класс Item представляет игровой
предмет
* id — Уникальный идентификатор предмета
* name — Название предмета
* quantity — Количество экземпляров
```
data class Item(
    val id: Int,
    val name: String,
    val amount: Int
)
```
### Кастомизация автоматически сгенерированных методов
```
override fun toString(): String {
        return "ID: $id, name: $name, amount: $amount"
    }
```
### Декомпозиция (Destructuring Declaration)
Автоматическое разложение объекта на отдельные переменные.
Используются сгенерированные функции component1(), component2(), component3():
```
val(id, name, amount) = betterSword
println("$id, $name, $amount")
```
## Абстрактные классы
Это базовый класс, от которого нельзя создать объект
напрямую. Он используется для описания общей логики и структуры для группы
связанных классов.

Пример:

```
abstract class Human(val name:String) {
    abstract var age: Int
    abstract fun hello()
}
```
Наследование
```
class Person(name: String) : Human(name) {
    override var age: Int = 1
    override fun hello() {
        println("My name is $name")
    }
}
```
## Интерфейсы
Контракт — набор функциональности, который
должен реализовать класс.

Пример: 

Определяем интерфейс видео-плеера
```
interface VideoPlayable {
    fun play()
}
```
Определяем интерфейс аудио-плеера
```
interface AudioPlayable {
    fun play()
}
```
Создадим класс, реализующий оба интерфейса, и в нём переопределим метод для обоих интерфейсов
```
class MediaPlayer : VideoPlayable, AudioPlayable {
override fun play() {
println("Playing audio and video")
    }
}
```
***
# Galaxy Outpost Manager
Учебный проект на Kotlin, демонстрирующий основы объектно-ориентированного программирования и
архитектурные приёмы языка.
***
## Sealed-классы

**Sealed-классы** используются для представления ограниченного набора состояний или результатов, которые
известны на этапе компиляции.

Они позволяют:
- гарантировать обработку всех возможных вариантов;
- безопасно использовать конструкцию when без else;
- удобно описывать состояния, события и результаты действий.

### Пример: результат работы модуля
```csharp
sealed-class ModuleResult {
    data class Success(val message: String) : ModuleResult()
    data class ResourceProduced(val resourceName: String, val amount: Int) : ModuleResult()
    data class NotEnoughResources(
        val resourceName: String,
        val required: Int,
        val available: Int
    ) : ModuleResult()
    data class Error(val reason: String) : ModuleResult()
}
```
***
## Object в Kotlin
**object** — это специальная конструкция Kotlin, которая создаёт единственный экземпляр класса (Singleton).

Особенности:
- создаётся при первом обращении;
- существует в одном экземпляре;
- не имеет конструктора.
### Пример: глобальный логгер
```
object Logger {
private var counter = 0
    fun log(message: String) {
        counter++
        println("[$counter] $message")
    }
}
```
### Использование:
```
Logger.log("Инициализация системы")
Logger.log("Модуль запущен")
```
**object** удобно использовать для:
- логгеров;
- конфигураций;
- состояний без данных в sealed-классах;
- утилитарных классов.